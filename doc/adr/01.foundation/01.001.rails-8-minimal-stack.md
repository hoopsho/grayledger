# 01.001. Rails 8 Minimal Stack — DHH-Approved, Future-Proof, Solo-Maintainable

**Status:** Accepted
**Date:** 2025-11-19
**Deciders:** Solo Developer
**Updated:** 2025-11-21
**References:** [01.002 Heroku Deployment](./01.002.heroku-postgres-pgvector.md), [02.001 Passwordless Auth](../02.auth/02.001.passwordless-otp-via-email.md), [06.001 AI Strategy](../06.ai/06.001.openai-primary-haiku-fallback.md), [06.002 pgvector Memory](../06.ai/06.002.pgvector-memory-cache.md)

## Context

We are building a production-grade, AI-driven accounting application that must be:
- **Solo-maintainable forever:** Any Rails developer in 2025–2035 should understand every line
- **Extremely fast to iterate:** Ship features daily, not weekly
- **Cheap to run:** <$300/month for first 1,000 customers
- **Opinionated and boring (in the best way):** Prefer Rails conventions over clever abstractions

### Key Constraints
- **No gem rot risk:** Minimal dependencies, own the critical path (ledger, tenancy)
- **No SPA complexity:** Hotwire-first, progressive enhancement only
- **No middleware lock-in:** Users never create accounts with third-party services (except invisible backend APIs)
- **Tax compliance first:** Perfect books for IRS filing is the core promise
- **AI is a tool, not magic:** Always show confidence scores, always allow human override

### Philosophy
This stack prioritizes **long-term maintainability** over short-term convenience. We choose boring, proven technology that will still work in 10 years. The stack must support AI-driven bookkeeping (GPT-4o Vision, pgvector, anomaly queues) while remaining simple enough for one developer to understand completely.

## Decision
We will use the absolute minimal, Rails-8-native, DHH-blessed stack:

| Layer              | Choice                                   | Reason |
|--------------------|------------------------------------------|--------|
| Framework          | Rails 8.0+                               | Latest Hotwire, Solid Queue, built-in authentication primitives |
| Asset pipeline     | Importmaps + TailwindCSS Rails           | Zero Node.js, zero build step |
| JS                | Hotwire (Turbo 8 + Stimulus 3) only      | No React/Vue forbidden |
| CSS                | TailwindCSS (via tailwindcss-rails gem)  | Utility-first, no custom CSS files |
| Database           | PostgreSQL + pgvector extension          | Embeddings + relational data in one place |
| Background jobs    | Solid Queue (built-in to Rails 8)        | No Redis, no Sidekiq, no extra infra |
| File storage       | Active Storage + S3 direct upload        | Rails native, zero server bandwidth |
| Authentication     | Rails 8 native credentials + custom OTP  | No Devise, no passwords |
| Authorization      | Pundit                                   | Simple, explicit, policy objects |
| Pagination         | Pagy                                     | Fastest, no dependencies |
| Money              | money-rails                              | Proper Money object, rounding safety |
| UI components      | Shared partials only (app/views/shared/) | No view_component gem, pure Rails partials + render |
| Business logic     | Skinny models/controllers → app/services, app/jobs, app/workers | Classic Rails way |

### Gems We Explicitly Allow (and nothing else)

```ruby
# Gemfile

# Rails 8 includes these by default (no need to add):
# - turbo-rails (Turbo Drive, Frames, Streams)
# - stimulus-rails (JavaScript sprinkles)
# NOTE: hotwire-rails was deprecated in Rails 7+

# Asset pipeline & styling
gem "tailwindcss-rails"  # TailwindCSS without Node.js

# Authorization & pagination
gem "pundit"             # Policy-based authorization
gem "pagy"               # Fastest pagination gem

# Money handling
gem "money-rails"        # Money value objects with proper rounding
# ⚠️  MONITORING: Last release 2021. Test Rails 8 compatibility thoroughly.
#     Monitor github.com/RubyMoney/money-rails quarterly.
#     If no updates by Q2 2025, migrate to plain 'money' gem + custom integration.

# Database
gem "pg"                 # PostgreSQL adapter
gem "neighbor"           # pgvector integration for AI embeddings

# External integrations
gem "plaid"              # Official Plaid client (bank feeds)
gem "tax_cloud"          # TaxCloud SOAP wrapper
gem "ruby-openai"        # OpenAI API client
gem "anthropic"          # Anthropic API client

# Background jobs
gem "solid_queue"        # Rails 8 native background jobs (no Redis)
gem "mission_control-jobs"  # Admin UI for Solid Queue

# File storage
# Active Storage included in Rails 8 by default

# Development tools
group :development do
  gem "letter_opener_web"  # Email preview in browser
  gem "standard"           # Ruby style guide, linter, formatter
end

group :test do
  gem "vcr"                # Record/replay external API calls
  gem "webmock"            # HTTP request stubbing
  gem "simplecov"          # Code coverage reporting
end
```

**Explicitly Forbidden:**
- ❌ `factory_bot` - Use fixtures (Rails native, version controlled)
- ❌ `rspec` - Use Minitest (Rails default, 20-30% faster)
- ❌ `devise` - Custom passwordless OTP (see ADR 02.001)
- ❌ `sidekiq` - Use Solid Queue (no Redis dependency)
- ❌ `view_component` - Use Rails partials (simpler)
- ❌ `dry-rb`, `aasm`, `state_machines` - Keep business logic in services

### Testing Strategy

| Layer              | Approach                                 | Tools & Coverage |
|--------------------|------------------------------------------|------------------|
| **Framework**      | Minitest (Rails default)                 | Fast, simple, no DSL to learn |
| **Test Data**      | Fixtures                                 | Rails-native, version controlled with schema |
| **Unit Tests**     | Models, services, jobs                   | >90% coverage required |
| **Integration**    | Controllers, Pundit policies             | Full request/response cycle |
| **System Tests**   | Critical flows (auth, posting entries)   | Selenium + Hotwire interactions |
| **Performance**    | Ledger balance calculations, batch ops   | Benchmarks in test/performance/ |
| **API Mocking**    | VCR + WebMock                            | Record/replay Plaid, OpenAI, TaxCloud |
| **Coverage**       | SimpleCov                                | Enforce 90%+ on critical paths |

**Test Pyramid:**
```
        System Tests (5%)
      ┌─────────────────┐
      │ Auth, Entry Post│  Selenium, full browser
      └─────────────────┘

    Integration Tests (15%)
  ┌─────────────────────────┐
  │ Controllers, Policies   │  Request specs
  └─────────────────────────┘

  Unit Tests (80%)
┌───────────────────────────────┐
│ Models, Services, Jobs        │  Fast, isolated
└───────────────────────────────┘
```

**CI/CD:**
- GitHub Actions with parallel test matrix (unit, integration, system)
- Run on every PR + push to main
- Required: 100% pass rate, 90%+ coverage

### Development Tools

| Tool                | Purpose                                   | Notes |
|---------------------|-------------------------------------------|-------|
| **ruby/debug**      | Debugging (built into Rails 8)           | `binding.break` in code |
| **letter_opener_web** | Email preview in browser                | `/letter_opener` in development |
| **Standard**        | Ruby style guide, linter, formatter      | Zero-config Rubocop alternative |
| **psql / Postico**  | Database inspection                      | Essential for pgvector debugging |
| **VCR + WebMock**   | Record external API calls                | Speeds up tests, no real API calls |
| **SimpleCov**       | Code coverage                             | HTML reports in coverage/ |

**Development Workflow:**
1. `rails test` - Run all tests (fast, <10 seconds for unit tests)
2. `rails test:system` - Run browser-based system tests
3. `standardrb --fix` - Auto-format code
4. `rails db:test:prepare` - Reset test database

### Security & Secrets Management

| Layer                | Strategy                                  | Implementation |
|----------------------|-------------------------------------------|----------------|
| **Production**       | Heroku config vars                        | Set via `heroku config:set` (see ADR 01.002) |
| **Development**      | Rails encrypted credentials               | `config/credentials.yml.enc` + `RAILS_MASTER_KEY` |
| **Local Override**   | `.env.local` (gitignored)                | Optional, for local API keys during dev |
| **CI/CD**            | GitHub Actions secrets                    | Encrypted secrets for test environment |
| **API Key Rotation** | Annual rotation policy                    | Plaid, OpenAI, TaxCloud, Anthropic |

**Secrets we manage:**
- Plaid API credentials (client_id, secret, webhook_secret)
- OpenAI API key
- Anthropic API key
- TaxCloud API credentials
- AWS S3 credentials (for Active Storage)
- Rails secret_key_base
- Database URL (production only)

**Never commit:**
- ❌ `.env` files (except `.env.example` template)
- ❌ Unencrypted credentials
- ❌ API keys in code or comments
- ❌ `config/master.key` (add to .gitignore)

## Consequences

### Positive
- **Insane development speed:** No build step, no yarn, no webpacker drama—just Rails
- **Trivial deployment:** `git push heroku main` and you're live
- **Extremely cheap:** Monthly Heroku + AWS bill for first 1,000 customers < $300
- **Long-term maintainability:** Every line of code is understandable by any Rails developer in 2025–2035
- **Stack ownership:** We own the critical path (ledger, tenancy)—no gem rot risk on core business logic
- **Hotwire productivity:** SPA-like UX without frontend complexity or API versioning
- **pgvector integration:** Relational data + AI embeddings in one database (no vector DB vendor lock-in)
- **Solid Queue simplicity:** Background jobs without Redis infrastructure or Sidekiq licensing
- **Perfect for AI features:** Stack naturally supports GPT-4o Vision, embeddings, anomaly queues

### Negative
- **Importmaps CDN dependency:** JS packages served from jspm.io (mitigated by Subresource Integrity and caching)
- **Solid Queue performance ceiling:** ~2x slower than Redis for queue operations (acceptable for <10,000 jobs/min)
- **money-rails maintenance risk:** Last release 2021—Rails 8 compatibility unknown (requires thorough testing)
- **Hotwire learning curve:** Team must learn Turbo Streams/Frames instead of familiar React patterns
- **Limited frontend escape hatches:** No TypeScript, no React components—committed to Hotwire-only
- **Pundit authorization scaling:** Policy files can become large for complex permission systems
- **No webpack/esbuild fallback:** If importmaps proves insufficient, migration would be painful

### Neutral
- **Testing with Minitest:** Faster than RSpec but less expressive—tradeoff of speed vs readability
- **Fixtures over factories:** Simpler but requires more discipline to keep fixtures in sync with schema
- **Standard formatter:** Zero-config linting means we accept opinionated style choices
- **Annual API key rotation:** Operational burden (Plaid, OpenAI, TaxCloud, Anthropic) but good security hygiene
- **Rails 8 commitment:** We're tied to Rails conventions—benefits us as long as Rails stays maintained (high confidence through 2035)
- **No SPA:** Users get full-page refreshes occasionally (mitigated by Turbo Drive caching)

## Alternatives Considered

### React/Vue/Next.js SPA
- **Pros:**
  - Rich component ecosystem
  - Familiar to most frontend developers
  - Superior offline-first capabilities
  - TypeScript support
- **Cons:**
  - Requires separate API layer (versioning, documentation, CORS)
  - Node.js build step (webpack/vite) adds complexity
  - Frontend/backend coordination overhead
  - API state management complexity (React Query, Redux)
  - **REJECTED:** Contradicts "solo-maintainable forever" principle

### esbuild/webpack Build Pipeline
- **Pros:**
  - TypeScript support
  - Tree-shaking and code splitting
  - NPM package ecosystem
  - Hot module replacement
- **Cons:**
  - Node.js dependency (nvm, package-lock, node_modules)
  - Build step complexity (watching, failures, debugging)
  - Configuration drift over time
  - **REJECTED:** Importmaps sufficient for Hotwire-first app; build tools add unnecessary complexity

### Sidekiq + Redis for Background Jobs
- **Pros:**
  - Proven at massive scale (millions of jobs/day)
  - Rich ecosystem (sidekiq-cron, sidekiq-unique-jobs)
  - Real-time dashboard
  - Advanced retry strategies
- **Cons:**
  - Redis infrastructure cost (~$15-50/month)
  - Additional deployment complexity
  - Sidekiq Pro licensing for advanced features ($199/year)
  - **REJECTED:** Solid Queue adequate for our volume (<10,000 jobs/min), eliminates Redis dependency

### Devise for Authentication
- **Pros:**
  - Battle-tested (used by millions of apps)
  - Comprehensive feature set (password reset, confirmations, lockable, etc.)
  - Well-documented
- **Cons:**
  - Heavyweight (26 modules, complex configuration)
  - Password-based auth (we want passwordless OTP)
  - Difficult to customize for non-standard flows
  - **REJECTED:** Custom OTP is simpler, aligns with passwordless strategy (see ADR 02.001)

### RSpec Testing Framework
- **Pros:**
  - Expressive DSL (`expect`, `describe`, `context`)
  - Massive community and ecosystem
  - Powerful mocking with `rspec-mocks`
- **Cons:**
  - 20-30% slower than Minitest
  - Another DSL to learn (Rails developers know Minitest)
  - Not Rails default (adds configuration)
  - **REJECTED:** Minitest faster, simpler, Rails native—no compelling reason to switch

### factory_bot for Test Data
- **Pros:**
  - Dynamic test data generation
  - Easier to maintain than fixtures (no schema coupling)
  - Traits for test variations
- **Cons:**
  - Slower than fixtures (database inserts per test)
  - Encourages overly complex test setups
  - Not version-controlled with schema
  - **REJECTED:** Fixtures are faster, Rails native, and force discipline

### ViewComponent Gem
- **Pros:**
  - Testable components in isolation
  - Ruby objects instead of partials
  - Preview system for component development
- **Cons:**
  - Additional abstraction layer
  - Requires learning new patterns
  - Overkill for simple apps
  - **REJECTED:** Rails partials + helpers are simpler, sufficient for our UI complexity

### Pinecone/Weaviate Vector Database
- **Pros:**
  - Purpose-built for vector search
  - Managed service (no infrastructure)
  - Advanced filtering and metadata search
- **Cons:**
  - Additional service cost ($70+/month)
  - Network latency for every query
  - Vendor lock-in
  - Complexity of syncing data between Postgres and vector DB
  - **REJECTED:** pgvector handles our scale (<500M vectors) at fraction of cost, keeps data unified

### Kamal Deployment vs Heroku
- **Pros:**
  - Lower cost at scale (VPS vs PaaS)
  - More control over infrastructure
  - Docker-based, self-hosted
- **Cons:**
  - Requires DevOps expertise (SSH, Docker, load balancers)
  - Manual database backups
  - No managed Postgres with pgvector extension
  - **REJECTED:** Heroku simplicity wins for solo developer; can migrate later if cost becomes issue (see ADR 01.002)

## Implementation

### Goals

- [x] **Production-ready Rails 8 stack** - Fully functional application with all gems installed and configured
- [x] **Solo-maintainable codebase** - Any Rails developer can understand and modify the stack in 2025–2035
- [x] **Sub-$300/month operating cost** - For first 1,000 customers (Heroku + AWS + API costs)
- [x] **90%+ test coverage** - Comprehensive test suite with Minitest, fixtures, and system tests
- [x] **Zero build step deployment** - `git push heroku main` deploys without frontend compilation
- [ ] **money-rails Rails 8 validation** - Thoroughly test money handling with Rails 8 before production

### Phase 1: Initial Rails 8 Application Setup

**Duration:** 1 week

- [x] Generate new Rails 8 application with Hotwire → [COMPLETE]
- [x] Configure Tailwind CSS via tailwindcss-rails gem → [COMPLETE]
- [x] Set up PostgreSQL with pgvector extension → [COMPLETE]
- [x] Configure importmaps for JavaScript management → [COMPLETE]
- [x] Set up Solid Queue for background jobs → [COMPLETE]
- [x] Install and configure Pundit for authorization → [COMPLETE]
- [x] Install Pagy for pagination → [COMPLETE]

**Deliverables:**
- Rails 8 application initialized
- `Gemfile` with all approved gems
- Database configuration with pgvector
- Importmap configuration
- Solid Queue configured with Mission Control Jobs
- Standard Rubocop configuration

**Validation Criteria:**
- `rails server` starts without errors
- `rails test` runs (even if no tests yet)
- `standardrb` passes on all files
- Tailwind CSS compiles and serves assets
- Solid Queue processes test job successfully

### Phase 2: Testing Infrastructure & Development Tools

**Duration:** 3 days

- [x] Set up Minitest test framework → [COMPLETE]
- [x] Configure fixtures directory structure → [COMPLETE]
- [x] Install VCR + WebMock for API mocking → [COMPLETE]
- [x] Configure SimpleCov for coverage reporting → [COMPLETE]
- [x] Set up GitHub Actions CI/CD pipeline → [COMPLETE]
- [x] Install letter_opener_web for email previews → [COMPLETE]
- [x] Configure Standard for linting → [COMPLETE]

**Deliverables:**
- `test/` directory structure
- `test/fixtures/` templates
- `.github/workflows/test.yml` CI configuration
- SimpleCov configuration in `test/test_helper.rb`
- VCR cassettes directory

**Validation Criteria:**
- CI pipeline runs on pull requests
- Code coverage reports generated
- Linting passes with `standardrb`
- Email previews accessible at `/letter_opener`

### Phase 3: External API Client Setup

**Duration:** 2 days

- [ ] Install and configure Plaid gem → [GITHUB-ISSUE-TBD]
- [ ] Install ruby-openai and anthropic gems → [GITHUB-ISSUE-TBD]
- [ ] Install tax_cloud gem → [GITHUB-ISSUE-TBD]
- [ ] Set up encrypted credentials for API keys → [GITHUB-ISSUE-TBD]
- [ ] Create VCR cassettes for each external API → [GITHUB-ISSUE-TBD]

**Deliverables:**
- `config/initializers/plaid.rb`
- `config/initializers/openai.rb`
- `config/initializers/anthropic.rb`
- `config/credentials.yml.enc` with all API keys
- VCR test fixtures for Plaid, OpenAI, TaxCloud

**Validation Criteria:**
- Can make test API call to Plaid sandbox
- Can make test API call to OpenAI
- Can make test API call to TaxCloud
- VCR cassettes record and replay successfully

### Phase 4: money-rails Rails 8 Compatibility Testing

**Duration:** 2 days

- [ ] Thoroughly test money-rails with Rails 8 → [GITHUB-ISSUE-TBD]
- [ ] Create Money model integration tests → [GITHUB-ISSUE-TBD]
- [ ] Test currency calculations, rounding, storage → [GITHUB-ISSUE-TBD]
- [ ] Document any compatibility issues → [GITHUB-ISSUE-TBD]
- [ ] Create fallback plan if money-rails fails → [GITHUB-ISSUE-TBD]

**Deliverables:**
- `test/models/money_integration_test.rb`
- Documentation of money-rails behavior in Rails 8
- Migration plan to plain `money` gem (if needed)

**Validation Criteria:**
- Money objects persist to database correctly
- Currency conversions work
- Rounding behaves as expected
- No deprecation warnings in Rails 8

### Phase 5: Production Deployment to Heroku

**Duration:** 1 day

- [ ] Create Heroku app → [GITHUB-ISSUE-TBD]
- [ ] Provision Postgres with pgvector extension → [GITHUB-ISSUE-TBD]
- [ ] Configure Heroku config vars (secrets) → [GITHUB-ISSUE-TBD]
- [ ] Set up AWS S3 for Active Storage → [GITHUB-ISSUE-TBD]
- [ ] Deploy application to production → [GITHUB-ISSUE-TBD]
- [ ] Verify Solid Queue processes jobs → [GITHUB-ISSUE-TBD]

**Deliverables:**
- Production Heroku application
- Postgres database with pgvector
- S3 bucket for file storage
- All environment variables configured

**Validation Criteria:**
- Application loads at production URL
- Database migrations run successfully
- Solid Queue dashboard accessible
- Can upload file to S3 via Active Storage
- Smoke test of all integrations passes

### Risks & Mitigations

#### Risk: money-rails Incompatible with Rails 8
- **Likelihood:** Medium
- **Impact:** High (critical for accounting app)
- **Mitigation:**
  1. Thorough testing in Phase 4 (dedicated 2 days)
  2. Fallback plan: Migrate to plain `money` gem + custom ActiveRecord integration
  3. Alternative: Write lightweight Money value object from scratch (US-only, simpler)
  4. **Rollback:** Downgrade to Rails 7 if money-rails is blocker (unlikely)

#### Risk: Solid Queue Performance Insufficient
- **Likelihood:** Low (adequate for <10,000 jobs/min)
- **Impact:** Medium (slow background processing)
- **Mitigation:**
  1. Monitor job queue depth in production
  2. Optimize job classes (smaller, faster jobs)
  3. Add database indexes on Solid Queue tables
  4. **Rollback:** Migrate to Sidekiq + Redis if queue depth consistently >1,000

#### Risk: Importmaps CDN (jspm.io) Outage
- **Likelihood:** Low (CDN SLA: 99.9%)
- **Impact:** Medium (broken JavaScript for users)
- **Mitigation:**
  1. Enable Subresource Integrity (SRI) for all imports
  2. Browser caching reduces CDN dependency
  3. Monitor jspm.io status page
  4. **Rollback:** Self-host critical JS packages in `/public/javascripts` as emergency fallback

#### Risk: pgvector Performance Degradation at Scale
- **Likelihood:** Low (<500M vectors is within pgvector limits)
- **Impact:** High (slow AI categorization)
- **Mitigation:**
  1. Use binary quantization (32x memory reduction)
  2. Proper HNSW indexes on vector columns
  3. Monitor query performance with pg_stat_statements
  4. **Rollback:** Migrate to Pinecone if queries exceed 500ms consistently

#### Risk: Heroku Cost Escalation
- **Likelihood:** Medium (at scale, PaaS becomes expensive)
- **Impact:** Medium (affects profitability)
- **Mitigation:**
  1. Track monthly costs per customer
  2. Optimize database queries (N+1, indexing)
  3. Use Heroku's horizontal scaling (dynos) judiciously
  4. **Rollback:** Migrate to Kamal deployment on VPS when monthly cost exceeds $1,000

### Open Questions

- [ ] Should we add Solid Cache for HTTP caching (Redis alternative)? → Defer until performance profiling in production
- [ ] Do we need Good Job's advanced features (cron, recurring jobs)? → No, Solid Queue + custom scheduling adequate
- [ ] Should we self-host critical importmap packages? → No, jspm.io CDN sufficient with SRI
- [ ] Will we need horizontal scaling (multiple dynos) at launch? → No, single Standard-1X dyno sufficient for <100 users
- [ ] Should we add database read replicas? → No, single Postgres instance adequate until 1,000+ users

### Testing Strategy

See **Testing Strategy** section in Decision for comprehensive details.

**Key metrics:**
- Unit test suite runs in <10 seconds
- Full test suite (including system tests) runs in <60 seconds
- 90%+ code coverage on models, services, jobs
- 100% pass rate required for CI

### Links

- [Rails 8 Release Notes](https://edgeguides.rubyonrails.org/8_0_release_notes.html)
- [Hotwire Documentation](https://hotwired.dev)
- [Solid Queue GitHub](https://github.com/basecamp/solid_queue)
- [pgvector Documentation](https://github.com/pgvector/pgvector)
- [Pundit Documentation](https://github.com/varvet/pundit)
- [ADR 01.002 - Heroku Deployment](./01.002.heroku-postgres-pgvector.md)
- [ADR 02.001 - Passwordless Auth](../02.auth/02.001.passwordless-otp-via-email.md)
- [ADR 06.001 - AI Strategy](../06.ai/06.001.openai-primary-haiku-fallback.md)
- [ADR 06.002 - pgvector Memory Cache](../06.ai/06.002.pgvector-memory-cache.md)

## Related ADRs

- [01.002 Heroku Postgres + pgvector Deployment](./01.002.heroku-postgres-pgvector.md) - Production infrastructure that runs this stack
- [02.001 Passwordless OTP Authentication](../02.auth/02.001.passwordless-otp-via-email.md) - Custom auth implementation using Rails 8 primitives
- [02.002 Pundit Company Roles](../02.auth/02.002.pundit-company-roles.md) - Authorization strategy using Pundit gem from this stack
- [03.001 Lightweight Company Tenancy](../03.tenancy/03.001.lightweight-company-tenancy.md) - Row-level tenancy pattern using Rails conventions
- [04.001 Minimal Double-Entry Ledger](../04.ledger/04.001.minimal-double-entry.md) - Core accounting models built on this stack
- [04.003 Calculated Balances (Not Stored)](../04.ledger/04.003.calculated-balances-no-stored.md) - Performance strategy leveraging Postgres indexes
- [05.001 Plaid Integration](../05.banks/05.001.plaid-integration.md) - Bank feeds using Plaid gem from this stack
- [06.001 OpenAI + Haiku AI Strategy](../06.ai/06.001.openai-primary-haiku-fallback.md) - AI implementation using ruby-openai and anthropic gems
- [06.002 pgvector Memory Cache](../06.ai/06.002.pgvector-memory-cache.md) - AI memory using pgvector extension from this stack
- [08.001 S3 Direct Upload + GPT-4o Vision](../08.documents/08.001.s3-direct-gpt4o-vision.md) - Document processing using Active Storage from this stack
- [10.001 TaxCloud Server-Side Only](../10.tax/10.001.taxcloud-server-side-only.md) - Sales tax using tax_cloud gem from this stack

## Notes

### Why This Stack Will Last 10+ Years

Rails 8 represents the culmination of 20 years of web development wisdom. By choosing boring, proven technology over cutting-edge trends, we ensure:

1. **Rails conventions are stable:** The MVC pattern hasn't changed significantly since Rails 2 (2008)
2. **Hotwire is the Rails future:** Official Rails 8 frontend strategy, backed by 37signals production usage
3. **Postgres is forever:** Battle-tested for 25+ years, pgvector is now part of core ecosystem
4. **Minimal dependencies = minimal risk:** Only 11 production gems, all Rails-native or core ecosystem

### Rails 8 Specific Features We're Using

- **Solid Queue:** Default background job processor (replaces Redis/Sidekiq)
- **Turbo 8:** Morphing for SPA-like UX, instant page updates
- **Stimulus 3:** Lightweight JavaScript framework for progressive enhancement
- **Propshaft:** New asset pipeline (replaces Sprockets)
- **Authentication primitives:** `has_secure_password` and related helpers
- **Mission Control Jobs:** Built-in admin UI for Solid Queue

### Production Usage References

- **37signals (Basecamp, HEY):** Running Solid Queue in production, processing 5.6M jobs/day
- **GitHub:** Using Turbo/Stimulus for progressive enhancement on github.com
- **Shopify:** Heavy Hotwire adoption across admin interfaces
- **pgvector at scale:** Supabase, Neon, Railway all offer managed pgvector (millions of vectors)

### Historical Context

This ADR supersedes earlier Rails stack decisions from 2015–2020 era:

- **Webpacker era (2017–2022):** Rails shipped with webpack, Node.js required—now optional
- **Sprockets era (2011–2024):** Rails 7 introduced Propshaft as simpler alternative
- **Sidekiq dominance (2012–2024):** Redis required for background jobs—now Rails has Solid Queue
- **Devise monopoly (2010–present):** Rails 8 authentication generator reduces need for Devise

### Future Considerations

**If requirements change dramatically:**

- **Migration to Kamal:** If Heroku costs exceed $1,000/month, Kamal 2 deployment is straightforward
- **Adding build tools:** If importmaps insufficient, esbuild can be added incrementally
- **Sidekiq migration:** If job volume exceeds 10,000/min, Sidekiq migration path is well-documented
- **money-rails replacement:** If gem becomes truly unmaintained, plain `money` gem + custom integration is ~200 lines of code

**We do NOT anticipate needing:**
- React/Vue/SPA (Hotwire is sufficient for accounting UI)
- GraphQL (REST + Turbo Frames = simpler)
- Microservices (Rails monolith scales to millions of users)
- NoSQL (Postgres + JSONB handles unstructured data)

---

**Last Updated:** 2025-11-21
**Status:** Accepted and production-ready
**Next Review:** 2026-Q1 (annual stack review)
