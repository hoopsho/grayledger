# 01.001. Rails 8 Minimal Stack — DHH-Approved, Future-Proof, Solo-Maintainable

**Status:** Accepted
**Date:** 2025-11-19
**Deciders:** Solo Developer
**Updated:** 2025-11-21
**References:** [01.002 Heroku Deployment](./01.002.heroku-postgres-pgvector.md), [02.001 Passwordless Auth](../02.auth/02.001.passwordless-otp-via-email.md), [06.001 AI Strategy](../06.ai/06.001.openai-primary-haiku-fallback.md), [06.002 pgvector Memory](../06.ai/06.002.pgvector-memory-cache.md)

## Context

We are building a production-grade, AI-driven accounting application that must be:
- **Solo-maintainable forever:** Any Rails developer in 2025–2035 should understand every line
- **Extremely fast to iterate:** Ship features daily, not weekly
- **Cheap to run:** <$300/month for first 1,000 customers
- **Opinionated and boring (in the best way):** Prefer Rails conventions over clever abstractions

### Key Constraints
- **No gem rot risk:** Minimal dependencies, own the critical path (ledger, tenancy)
- **No SPA complexity:** Hotwire-first, progressive enhancement only
- **No middleware lock-in:** Users never create accounts with third-party services (except invisible backend APIs)
- **Tax compliance first:** Perfect books for IRS filing is the core promise
- **AI is a tool, not magic:** Always show confidence scores, always allow human override

### Philosophy
This stack prioritizes **long-term maintainability** over short-term convenience. We choose boring, proven technology that will still work in 10 years. The stack must support AI-driven bookkeeping (GPT-4o Vision, pgvector, anomaly queues) while remaining simple enough for one developer to understand completely.

## Decision
We will use the absolute minimal, Rails-8-native, DHH-blessed stack:

| Layer              | Choice                                   | Reason |
|--------------------|------------------------------------------|--------|
| Framework          | Rails 8.0+                               | Latest Hotwire, Solid Queue, built-in authentication primitives |
| Asset pipeline     | Importmaps + TailwindCSS Rails           | Zero Node.js, zero build step |
| JS                | Hotwire (Turbo 8 + Stimulus 3) only      | No React/Vue forbidden |
| CSS                | TailwindCSS (via tailwindcss-rails gem)  | Utility-first, no custom CSS files |
| Database           | PostgreSQL + pgvector extension          | Embeddings + relational data in one place |
| Background jobs    | Solid Queue (built-in to Rails 8)        | No Redis, no Sidekiq, no extra infra |
| File storage       | Active Storage + S3 direct upload        | Rails native, zero server bandwidth |
| Authentication     | Rails 8 native credentials + custom OTP  | No Devise, no passwords |
| Authorization      | Pundit                                   | Simple, explicit, policy objects |
| Pagination         | Pagy                                     | Fastest, no dependencies |
| Money              | money-rails                              | Proper Money object, rounding safety |
| UI components      | Shared partials only (app/views/shared/) | No view_component gem, pure Rails partials + render |
| Business logic     | Skinny models/controllers → app/services, app/jobs, app/workers | Classic Rails way |
| Rate limiting      | Rack::Attack                             | Throttle OTP, API endpoints, prevent abuse |
| Caching            | Solid Cache + Russian Doll caching       | HTTP responses, fragments, AI embeddings |
| Error tracking     | Rails logger + custom metrics            | Business metrics (anomaly queue, AI confidence), defer APM |

### Gems We Explicitly Allow (and nothing else)

```ruby
# Gemfile

# Rails 8 includes these by default (no need to add):
# - turbo-rails (Turbo Drive, Frames, Streams)
# - stimulus-rails (JavaScript sprinkles)
# NOTE: hotwire-rails was deprecated in Rails 7+

# Asset pipeline & styling
gem "tailwindcss-rails"  # TailwindCSS without Node.js

# Authorization & pagination
gem "pundit"             # Policy-based authorization
gem "pagy"               # Fastest pagination gem

# Money handling
gem "money-rails"        # Money value objects with proper rounding
# ⚠️  MONITORING: Last release 2021. Test Rails 8 compatibility thoroughly.
#     Monitor github.com/RubyMoney/money-rails quarterly.
#     If no updates by Q2 2025, migrate to plain 'money' gem + custom integration.

# Database
gem "pg"                 # PostgreSQL adapter
gem "neighbor"           # pgvector integration for AI embeddings

# External integrations
gem "plaid"              # Official Plaid client (bank feeds)
gem "tax_cloud"          # TaxCloud SOAP wrapper
gem "ruby-openai"        # OpenAI API client
gem "anthropic"          # Anthropic API client

# Background jobs
gem "solid_queue"        # Rails 8 native background jobs (no Redis)
gem "mission_control-jobs"  # Admin UI for Solid Queue

# File storage
# Active Storage included in Rails 8 by default

# Performance & security
gem "rack-attack"         # Rate limiting and throttling
gem "solid_cache"         # Rails 8 native HTTP caching (Redis alternative)

# Development tools
group :development do
  gem "letter_opener_web"  # Email preview in browser
  gem "standard"           # Ruby style guide, linter, formatter
end

group :test do
  gem "vcr"                # Record/replay external API calls
  gem "webmock"            # HTTP request stubbing
  gem "simplecov"          # Code coverage reporting
end
```

**Explicitly Forbidden:**
- ❌ `factory_bot` - Use fixtures (Rails native, version controlled)
- ❌ `rspec` - Use Minitest (Rails default, 20-30% faster)
- ❌ `devise` - Custom passwordless OTP (see ADR 02.001)
- ❌ `sidekiq` - Use Solid Queue (no Redis dependency)
- ❌ `view_component` - Use Rails partials (simpler)
- ❌ `dry-rb`, `aasm`, `state_machines` - Keep business logic in services

### Testing Strategy

| Layer              | Approach                                 | Tools & Coverage |
|--------------------|------------------------------------------|------------------|
| **Framework**      | Minitest (Rails default)                 | Fast, simple, no DSL to learn |
| **Test Data**      | Fixtures                                 | Rails-native, version controlled with schema |
| **Unit Tests**     | Models, services, jobs                   | >90% coverage required |
| **Integration**    | Controllers, Pundit policies             | Full request/response cycle |
| **System Tests**   | Critical flows (auth, posting entries)   | Selenium + Hotwire interactions |
| **Performance**    | Ledger balance calculations, batch ops   | Benchmarks in test/performance/ |
| **API Mocking**    | VCR + WebMock                            | Record/replay Plaid, OpenAI, TaxCloud |
| **Coverage**       | SimpleCov                                | Enforce 90%+ on critical paths |

**Test Pyramid:**
```
        System Tests (5%)
      ┌─────────────────┐
      │ Auth, Entry Post│  Selenium, full browser
      └─────────────────┘

    Integration Tests (15%)
  ┌─────────────────────────┐
  │ Controllers, Policies   │  Request specs
  └─────────────────────────┘

  Unit Tests (80%)
┌───────────────────────────────┐
│ Models, Services, Jobs        │  Fast, isolated
└───────────────────────────────┘
```

**CI/CD:**
- GitHub Actions with parallel test matrix (unit, integration, system)
- Run on every PR + push to main
- Required: 100% pass rate, 90%+ coverage

### Development Tools

| Tool                | Purpose                                   | Notes |
|---------------------|-------------------------------------------|-------|
| **ruby/debug**      | Debugging (built into Rails 8)           | `binding.break` in code |
| **letter_opener_web** | Email preview in browser                | `/letter_opener` in development |
| **Standard**        | Ruby style guide, linter, formatter      | Zero-config Rubocop alternative |
| **psql / Postico**  | Database inspection                      | Essential for pgvector debugging |
| **VCR + WebMock**   | Record external API calls                | Speeds up tests, no real API calls |
| **SimpleCov**       | Code coverage                             | HTML reports in coverage/ |

**Development Workflow:**
1. `rails test` - Run all tests (fast, <10 seconds for unit tests)
2. `rails test:system` - Run browser-based system tests
3. `standardrb --fix` - Auto-format code
4. `rails db:test:prepare` - Reset test database

### Rate Limiting Strategy (Rack::Attack)

**Critical for:** Preventing abuse, protecting API costs, ensuring system stability

| Endpoint/Action           | Limit                          | Rationale |
|---------------------------|--------------------------------|-----------|
| **OTP Generation**        | 3 requests per 15 min per IP   | Prevent email spam, enumeration attacks |
| **OTP Validation**        | 5 attempts per 10 min per token | Prevent brute-force of 6-digit codes |
| **Entry Creation**        | 100 entries per hour per company | Prevent accidental mass creation, database overload |
| **Receipt Upload (AI)**   | 50 uploads per hour per user    | Prevent GPT-4o Vision API cost overruns ($0.01/image) |
| **AI Categorization**     | 200 requests per hour per company | Prevent OpenAI API abuse (embeddings, completions) |
| **API Endpoints (general)** | 1000 requests per hour per IP | DDoS protection, maintain database performance |

**Implementation:**
```ruby
# config/initializers/rack_attack.rb

# Throttle OTP generation (magic link requests)
Rack::Attack.throttle("otp/ip", limit: 3, period: 15.minutes) do |req|
  req.ip if req.path == "/auth/login" && req.post?
end

# Throttle AI-powered receipt uploads
Rack::Attack.throttle("receipts/user", limit: 50, period: 1.hour) do |req|
  req.env["warden"].user&.id if req.path.start_with?("/receipts") && req.post?
end

# Throttle entry creation (accounting entries)
Rack::Attack.throttle("entries/company", limit: 100, period: 1.hour) do |req|
  Current.company&.id if req.path == "/entries" && req.post?
end

# Block bad actors (after 10 forbidden responses in 10 minutes)
Rack::Attack.blocklist("block repeat offenders") do |req|
  Rack::Attack::Allow2Ban.filter(req.ip, maxretry: 10, findtime: 10.minutes, bantime: 1.hour) do
    req.env["rack.attack.throttle_data"]&.dig(:count) || 0 > 0
  end
end
```

**Response Headers:**
- `X-RateLimit-Limit`: Total requests allowed in period
- `X-RateLimit-Remaining`: Remaining requests in current period
- `X-RateLimit-Reset`: Unix timestamp when limit resets
- `Retry-After`: Seconds to wait before retry (when throttled)

**Monitoring:**
- Log all throttled requests to `log/rack_attack.log`
- Track throttle count as business metric (see Observability section)
- Alert if throttle rate exceeds 5% of total requests

### Caching Strategy (Solid Cache + Russian Doll)

**Philosophy:** Cache aggressively in production, disable entirely in development.

| Cache Type              | Target                          | Invalidation Strategy | TTL |
|-------------------------|--------------------------------|----------------------|-----|
| **HTTP Response**       | Dashboard, reports, chart of accounts | Sweep on new entry | 5 min |
| **Fragment (Russian Doll)** | Account balances in views    | Touch on entry update | N/A (auto-invalidated) |
| **AI Embeddings**       | pgvector similarity search results | Never (immutable once created) | ∞ |
| **Chart of Accounts**   | 30 parent accounts + sub-accounts | Sweep on account create/update | 1 hour |
| **Active Record**       | Company settings, user preferences | Write-through cache | 15 min |

**Implementation:**

```ruby
# config/environments/production.rb
config.cache_store = :solid_cache_store

# Russian Doll Caching in views
# app/views/accounts/index.html.erb
<% cache @company do %>
  <% @accounts.each do |account| %>
    <% cache account do %>
      <%= render account %>
    <% end %>
  <% end %>
<% end %>

# Fragment caching for expensive balance calculations
# app/views/dashboard/index.html.erb
<% cache "dashboard-#{Current.company.id}-#{@as_of_date}", expires_in: 5.minutes do %>
  <%= render "balance_summary", accounts: @accounts %>
<% end %>

# AI embedding similarity search caching
# app/services/ai_categorizer.rb
def find_similar_transactions(description)
  Rails.cache.fetch("ai_embedding:#{Digest::SHA256.hexdigest(description)}", expires_in: nil) do
    # pgvector similarity search (expensive query)
    EmbeddedTransaction.nearest_neighbors(:embedding, embedding_for(description), distance: "cosine").limit(5)
  end
end

# Chart of accounts caching (rarely changes)
def cached_chart_of_accounts
  Rails.cache.fetch("chart_of_accounts:#{Current.company.id}", expires_in: 1.hour) do
    Account.where(company: Current.company).includes(:parent).order(:code)
  end
end
```

**Cache Invalidation (Critical):**
- **Entry posting:** `Rails.cache.delete_matched("dashboard-#{company.id}-*")` + touch accounts
- **Account creation:** `Rails.cache.delete("chart_of_accounts:#{company.id}")`
- **AI correction (human override):** Create new embedding, old cache naturally expires (no invalidation needed)

**Cache Warming:**
- Pre-warm chart of accounts on company creation
- Pre-warm dashboard cache via background job every 10 minutes (off-peak)

**Development Environment:**
```ruby
# config/environments/development.rb
config.cache_store = :null_store  # Disable all caching in development
```

### Observability & Business Metrics

**Philosophy:** Track business-critical metrics first, defer expensive APM tools until justified by scale.

**Business Metrics (Custom):**

| Metric                          | Target              | Alert Threshold | Purpose |
|---------------------------------|---------------------|-----------------|---------|
| **Anomaly Queue Depth**         | < 50 items          | > 100 items     | Ensure human review doesn't bottleneck |
| **AI Confidence (avg)**         | > 95%               | < 90% for 1 hour | Detect model degradation or data drift |
| **Entry Posting Success Rate**  | > 99%               | < 95% for 10 min | Critical path monitoring (double-entry validation) |
| **GPT-4o Vision Success Rate**  | > 98%               | < 90% for 30 min | Receipt OCR reliability |
| **Ledger Calculation Time (p95)** | < 200ms          | > 500ms         | Performance degradation warning |
| **OTP Delivery Time (p95)**     | < 5 seconds         | > 30 seconds    | Email delivery issues |

**Implementation:**
```ruby
# app/models/concerns/trackable.rb
module Trackable
  extend ActiveSupport::Concern

  included do
    after_create :track_creation_metric
  end

  def track_creation_metric
    Rails.cache.increment("metrics:#{self.class.name.underscore}:created:#{Date.current}")
  end
end

# app/services/metrics_tracker.rb
class MetricsTracker
  def self.track_anomaly_queue_depth
    Rails.cache.write("metrics:anomaly_queue_depth", AnomalyQueueItem.pending.count)
  end

  def self.track_ai_confidence
    avg_confidence = Entry.where("created_at > ?", 1.hour.ago).average(:ai_confidence_score)
    Rails.cache.write("metrics:ai_confidence_avg_1h", avg_confidence)
  end

  def self.track_entry_posting_success
    total = Rails.cache.read("metrics:entry_posting:attempted:#{Date.current}") || 0
    failed = Rails.cache.read("metrics:entry_posting:failed:#{Date.current}") || 0
    success_rate = total.zero? ? 100 : ((total - failed).to_f / total * 100)
    Rails.cache.write("metrics:entry_posting_success_rate", success_rate)
  end
end

# Background job to collect metrics every 5 minutes
# app/jobs/metrics_collection_job.rb
class MetricsCollectionJob < ApplicationJob
  queue_as :default

  def perform
    MetricsTracker.track_anomaly_queue_depth
    MetricsTracker.track_ai_confidence
    MetricsTracker.track_entry_posting_success
  end
end
```

**Metrics Dashboard:**
- Custom admin page: `/admin/metrics` (Superuser-only, ADR 14.001)
- Shows all business metrics with 24-hour trends
- Color-coded: Green (healthy), Yellow (warning), Red (alert)

**Alerting:**
- Log warnings to `log/alerts.log` when thresholds exceeded
- Email platform team (`@grayledger.io` addresses) for critical alerts
- **No PagerDuty/Slack initially** - keep it simple, email is sufficient for solo developer

**Error Tracking:**
- Use Rails logger with structured logging (JSON format)
- Log all exceptions to `log/production.log` with request context
- **Defer Sentry/Honeybadger** until recurring errors justify cost ($29/month)

**APM (Application Performance Monitoring):**
- **Defer Scout/Skylight** ($39/month) until performance issues arise
- Use `ActiveSupport::Notifications` for custom instrumentation
- Log slow queries (> 100ms) via Postgres `log_min_duration_statement`

**Future Observability Upgrades (when monthly revenue > $10,000):**
1. Add Sentry for error tracking ($29/month)
2. Add Scout APM for performance monitoring ($39/month)
3. Add UptimeRobot for uptime monitoring (free tier)
4. Add Postgres read replica for analytics queries

### Security & Secrets Management

| Layer                | Strategy                                  | Implementation |
|----------------------|-------------------------------------------|----------------|
| **Production**       | Heroku config vars                        | Set via `heroku config:set` (see ADR 01.002) |
| **Development**      | Rails encrypted credentials               | `config/credentials.yml.enc` + `RAILS_MASTER_KEY` |
| **Local Override**   | `.env.local` (gitignored)                | Optional, for local API keys during dev |
| **CI/CD**            | GitHub Actions secrets                    | Encrypted secrets for test environment |
| **API Key Rotation** | Annual rotation policy                    | Plaid, OpenAI, TaxCloud, Anthropic |

**Secrets we manage:**
- Plaid API credentials (client_id, secret, webhook_secret)
- OpenAI API key
- Anthropic API key
- TaxCloud API credentials
- AWS S3 credentials (for Active Storage)
- Rails secret_key_base
- Database URL (production only)

**Never commit:**
- ❌ `.env` files (except `.env.example` template)
- ❌ Unencrypted credentials
- ❌ API keys in code or comments
- ❌ `config/master.key` (add to .gitignore)

## Consequences

### Positive
- **Insane development speed:** No build step, no yarn, no webpacker drama—just Rails
- **Trivial deployment:** `git push heroku main` and you're live
- **Extremely cheap:** Monthly Heroku + AWS bill for first 1,000 customers < $300 (no APM/error tracking costs)
- **Long-term maintainability:** Every line of code is understandable by any Rails developer in 2025–2035
- **Stack ownership:** We own the critical path (ledger, tenancy)—no gem rot risk on core business logic
- **Hotwire productivity:** SPA-like UX without frontend complexity or API versioning
- **pgvector integration:** Relational data + AI embeddings in one database (no vector DB vendor lock-in)
- **Solid Queue simplicity:** Background jobs without Redis infrastructure or Sidekiq licensing
- **Perfect for AI features:** Stack naturally supports GPT-4o Vision, embeddings, anomaly queues
- **Production-grade security:** Rack::Attack prevents abuse, rate limiting protects API costs
- **Aggressive caching:** Russian Doll + Solid Cache ensures sub-200ms responses even with 10,000+ entries
- **Business metrics first:** Custom observability focuses on AI confidence, anomaly queue—not vanity metrics
- **Cost-effective monitoring:** Defer expensive APM ($70/month) until revenue justifies it

### Negative
- **Importmaps CDN dependency:** JS packages served from jspm.io (mitigated by Subresource Integrity and caching)
- **Solid Queue performance ceiling:** ~2x slower than Redis for queue operations (acceptable for <10,000 jobs/min)
- **money-rails maintenance risk:** Last release 2021—Rails 8 compatibility unknown (requires thorough testing)
- **Hotwire learning curve:** Team must learn Turbo Streams/Frames instead of familiar React patterns
- **Limited frontend escape hatches:** No TypeScript, no React components—committed to Hotwire-only
- **Pundit authorization scaling:** Policy files can become large for complex permission systems
- **No webpack/esbuild fallback:** If importmaps proves insufficient, migration would be painful
- **Cache invalidation complexity:** Russian Doll caching requires discipline—sweeping wrong caches causes stale data
- **Rate limiting false positives:** Legitimate users may hit limits (e.g., bulk entry import via CSV)
- **Manual metrics tracking:** Custom observability requires maintenance—no automatic instrumentation like APM tools

### Neutral
- **Testing with Minitest:** Faster than RSpec but less expressive—tradeoff of speed vs readability
- **Fixtures over factories:** Simpler but requires more discipline to keep fixtures in sync with schema
- **Standard formatter:** Zero-config linting means we accept opinionated style choices
- **Annual API key rotation:** Operational burden (Plaid, OpenAI, TaxCloud, Anthropic) but good security hygiene
- **Rails 8 commitment:** We're tied to Rails conventions—benefits us as long as Rails stays maintained (high confidence through 2035)
- **No SPA:** Users get full-page refreshes occasionally (mitigated by Turbo Drive caching)

## Alternatives Considered

### React/Vue/Next.js SPA
- **Pros:**
  - Rich component ecosystem
  - Familiar to most frontend developers
  - Superior offline-first capabilities
  - TypeScript support
- **Cons:**
  - Requires separate API layer (versioning, documentation, CORS)
  - Node.js build step (webpack/vite) adds complexity
  - Frontend/backend coordination overhead
  - API state management complexity (React Query, Redux)
  - **REJECTED:** Contradicts "solo-maintainable forever" principle

### esbuild/webpack Build Pipeline
- **Pros:**
  - TypeScript support
  - Tree-shaking and code splitting
  - NPM package ecosystem
  - Hot module replacement
- **Cons:**
  - Node.js dependency (nvm, package-lock, node_modules)
  - Build step complexity (watching, failures, debugging)
  - Configuration drift over time
  - **REJECTED:** Importmaps sufficient for Hotwire-first app; build tools add unnecessary complexity

### Sidekiq + Redis for Background Jobs
- **Pros:**
  - Proven at massive scale (millions of jobs/day)
  - Rich ecosystem (sidekiq-cron, sidekiq-unique-jobs)
  - Real-time dashboard
  - Advanced retry strategies
- **Cons:**
  - Redis infrastructure cost (~$15-50/month)
  - Additional deployment complexity
  - Sidekiq Pro licensing for advanced features ($199/year)
  - **REJECTED:** Solid Queue adequate for our volume (<10,000 jobs/min), eliminates Redis dependency

### Devise for Authentication
- **Pros:**
  - Battle-tested (used by millions of apps)
  - Comprehensive feature set (password reset, confirmations, lockable, etc.)
  - Well-documented
- **Cons:**
  - Heavyweight (26 modules, complex configuration)
  - Password-based auth (we want passwordless OTP)
  - Difficult to customize for non-standard flows
  - **REJECTED:** Custom OTP is simpler, aligns with passwordless strategy (see ADR 02.001)

### RSpec Testing Framework
- **Pros:**
  - Expressive DSL (`expect`, `describe`, `context`)
  - Massive community and ecosystem
  - Powerful mocking with `rspec-mocks`
- **Cons:**
  - 20-30% slower than Minitest
  - Another DSL to learn (Rails developers know Minitest)
  - Not Rails default (adds configuration)
  - **REJECTED:** Minitest faster, simpler, Rails native—no compelling reason to switch

### factory_bot for Test Data
- **Pros:**
  - Dynamic test data generation
  - Easier to maintain than fixtures (no schema coupling)
  - Traits for test variations
- **Cons:**
  - Slower than fixtures (database inserts per test)
  - Encourages overly complex test setups
  - Not version-controlled with schema
  - **REJECTED:** Fixtures are faster, Rails native, and force discipline

### ViewComponent Gem
- **Pros:**
  - Testable components in isolation
  - Ruby objects instead of partials
  - Preview system for component development
- **Cons:**
  - Additional abstraction layer
  - Requires learning new patterns
  - Overkill for simple apps
  - **REJECTED:** Rails partials + helpers are simpler, sufficient for our UI complexity

### Pinecone/Weaviate Vector Database
- **Pros:**
  - Purpose-built for vector search
  - Managed service (no infrastructure)
  - Advanced filtering and metadata search
- **Cons:**
  - Additional service cost ($70+/month)
  - Network latency for every query
  - Vendor lock-in
  - Complexity of syncing data between Postgres and vector DB
  - **REJECTED:** pgvector handles our scale (<500M vectors) at fraction of cost, keeps data unified

### Kamal Deployment vs Heroku
- **Pros:**
  - Lower cost at scale (VPS vs PaaS)
  - More control over infrastructure
  - Docker-based, self-hosted
- **Cons:**
  - Requires DevOps expertise (SSH, Docker, load balancers)
  - Manual database backups
  - No managed Postgres with pgvector extension
  - **REJECTED:** Heroku simplicity wins for solo developer; can migrate later if cost becomes issue (see ADR 01.002)

## Implementation

### Goals

- [x] **Production-ready Rails 8 stack** - Fully functional application with all gems installed and configured
- [x] **Solo-maintainable codebase** - Any Rails developer can understand and modify the stack in 2025–2035
- [x] **Sub-$300/month operating cost** - For first 1,000 customers (Heroku + AWS + API costs, no APM/error tracking)
- [x] **90%+ test coverage** - Comprehensive test suite with Minitest, fixtures, and system tests
- [x] **Zero build step deployment** - `git push heroku main` deploys without frontend compilation
- [ ] **money-rails Rails 8 validation** - Thoroughly test money handling with Rails 8 before production
- [ ] **Production-grade security** - Rack::Attack configured with rate limiting on all sensitive endpoints
- [ ] **Battle-tested caching** - Solid Cache + Russian Doll caching for sub-200ms response times
- [ ] **Business metrics tracking** - Custom observability for AI confidence, anomaly queue, entry posting success

### Phase 1: Initial Rails 8 Application Setup

**Duration:** 1 week

- [x] Generate new Rails 8 application with Hotwire → [COMPLETE]
- [x] Configure Tailwind CSS via tailwindcss-rails gem → [COMPLETE]
- [x] Set up PostgreSQL with pgvector extension → [COMPLETE]
- [x] Configure importmaps for JavaScript management → [COMPLETE]
- [x] Set up Solid Queue for background jobs → [COMPLETE]
- [x] Install and configure Pundit for authorization → [COMPLETE]
- [x] Install Pagy for pagination → [COMPLETE]

**Deliverables:**
- Rails 8 application initialized
- `Gemfile` with all approved gems
- Database configuration with pgvector
- Importmap configuration
- Solid Queue configured with Mission Control Jobs
- Standard Rubocop configuration

**Validation Criteria:**
- `rails server` starts without errors
- `rails test` runs (even if no tests yet)
- `standardrb` passes on all files
- Tailwind CSS compiles and serves assets
- Solid Queue processes test job successfully

### Phase 2: Testing Infrastructure & Development Tools

**Duration:** 3 days

- [x] Set up Minitest test framework → [COMPLETE]
- [x] Configure fixtures directory structure → [COMPLETE]
- [x] Install VCR + WebMock for API mocking → [COMPLETE]
- [x] Configure SimpleCov for coverage reporting → [COMPLETE]
- [x] Set up GitHub Actions CI/CD pipeline → [COMPLETE]
- [x] Install letter_opener_web for email previews → [COMPLETE]
- [x] Configure Standard for linting → [COMPLETE]

**Deliverables:**
- `test/` directory structure
- `test/fixtures/` templates
- `.github/workflows/test.yml` CI configuration
- SimpleCov configuration in `test/test_helper.rb`
- VCR cassettes directory

**Validation Criteria:**
- CI pipeline runs on pull requests
- Code coverage reports generated
- Linting passes with `standardrb`
- Email previews accessible at `/letter_opener`

### Phase 3: External API Client Setup

**Duration:** 2 days

- [ ] Install and configure Plaid gem → [GITHUB-ISSUE-TBD]
- [ ] Install ruby-openai and anthropic gems → [GITHUB-ISSUE-TBD]
- [ ] Install tax_cloud gem → [GITHUB-ISSUE-TBD]
- [ ] Set up encrypted credentials for API keys → [GITHUB-ISSUE-TBD]
- [ ] Create VCR cassettes for each external API → [GITHUB-ISSUE-TBD]

**Deliverables:**
- `config/initializers/plaid.rb`
- `config/initializers/openai.rb`
- `config/initializers/anthropic.rb`
- `config/credentials.yml.enc` with all API keys
- VCR test fixtures for Plaid, OpenAI, TaxCloud

**Validation Criteria:**
- Can make test API call to Plaid sandbox
- Can make test API call to OpenAI
- Can make test API call to TaxCloud
- VCR cassettes record and replay successfully

### Phase 4: money-rails Rails 8 Compatibility Testing

**Duration:** 2 days

- [ ] Thoroughly test money-rails with Rails 8 → [GITHUB-ISSUE-TBD]
- [ ] Create Money model integration tests → [GITHUB-ISSUE-TBD]
- [ ] Test currency calculations, rounding, storage → [GITHUB-ISSUE-TBD]
- [ ] Document any compatibility issues → [GITHUB-ISSUE-TBD]
- [ ] Create fallback plan if money-rails fails → [GITHUB-ISSUE-TBD]

**Deliverables:**
- `test/models/money_integration_test.rb`
- Documentation of money-rails behavior in Rails 8
- Migration plan to plain `money` gem (if needed)

**Validation Criteria:**
- Money objects persist to database correctly
- Currency conversions work
- Rounding behaves as expected
- No deprecation warnings in Rails 8

### Phase 5: Production Deployment to Heroku

**Duration:** 1 day

- [ ] Create Heroku app → [GITHUB-ISSUE-TBD]
- [ ] Provision Postgres with pgvector extension → [GITHUB-ISSUE-TBD]
- [ ] Configure Heroku config vars (secrets) → [GITHUB-ISSUE-TBD]
- [ ] Set up AWS S3 for Active Storage → [GITHUB-ISSUE-TBD]
- [ ] Deploy application to production → [GITHUB-ISSUE-TBD]
- [ ] Verify Solid Queue processes jobs → [GITHUB-ISSUE-TBD]

**Deliverables:**
- Production Heroku application
- Postgres database with pgvector
- S3 bucket for file storage
- All environment variables configured

**Validation Criteria:**
- Application loads at production URL
- Database migrations run successfully
- Solid Queue dashboard accessible
- Can upload file to S3 via Active Storage
- Smoke test of all integrations passes

### Phase 6: Security Hardening & Rate Limiting

**Duration:** 2 days

- [ ] Install and configure Rack::Attack gem → [GITHUB-ISSUE-TBD]
- [ ] Implement OTP rate limiting (3 per 15 min) → [GITHUB-ISSUE-TBD]
- [ ] Implement AI API rate limiting (50 receipts/hour, 200 categorizations/hour) → [GITHUB-ISSUE-TBD]
- [ ] Implement entry creation rate limiting (100 entries/hour) → [GITHUB-ISSUE-TBD]
- [ ] Add rate limit response headers (X-RateLimit-*) → [GITHUB-ISSUE-TBD]
- [ ] Test rate limiting with Minitest integration tests → [GITHUB-ISSUE-TBD]
- [ ] Configure Rack::Attack logging and monitoring → [GITHUB-ISSUE-TBD]

**Deliverables:**
- `config/initializers/rack_attack.rb` with all throttle rules
- `test/integration/rate_limiting_test.rb` with comprehensive coverage
- `log/rack_attack.log` configuration
- Rate limit metrics tracking (throttled request count)

**Validation Criteria:**
- OTP generation throttled after 3 requests per 15 minutes
- Receipt upload throttled after 50 uploads per hour
- Entry creation throttled after 100 entries per hour
- Rate limit headers returned in responses
- Throttled requests logged to rack_attack.log
- Integration tests cover all rate limit scenarios

### Phase 7: Caching & Performance Optimization

**Duration:** 3 days

- [ ] Install and configure Solid Cache gem → [GITHUB-ISSUE-TBD]
- [ ] Implement Russian Doll caching in account views → [GITHUB-ISSUE-TBD]
- [ ] Add fragment caching for dashboard balance summary → [GITHUB-ISSUE-TBD]
- [ ] Cache AI embedding similarity search results → [GITHUB-ISSUE-TBD]
- [ ] Cache chart of accounts (1-hour TTL) → [GITHUB-ISSUE-TBD]
- [ ] Implement cache invalidation on entry posting → [GITHUB-ISSUE-TBD]
- [ ] Add cache warming for frequently accessed data → [GITHUB-ISSUE-TBD]
- [ ] Benchmark ledger performance with 10,000+ entries → [GITHUB-ISSUE-TBD]

**Deliverables:**
- `config/environments/production.rb` with Solid Cache configuration
- Russian Doll caching in `app/views/accounts/`, `app/views/dashboard/`
- Cache invalidation logic in `app/models/entry.rb`, `app/models/account.rb`
- Performance benchmarks in `test/performance/ledger_benchmark.rb`

**Validation Criteria:**
- Dashboard renders in < 200ms with 10,000 line items (cached)
- AI embedding queries cached (no duplicate pgvector searches)
- Chart of accounts cached for 1 hour
- Cache invalidation works correctly on entry posting
- Caching disabled in development environment (null_store)
- Performance benchmarks demonstrate 5x+ speedup with caching

### Phase 8: Observability & Business Metrics

**Duration:** 2 days

- [ ] Create MetricsTracker service for business metrics → [GITHUB-ISSUE-TBD]
- [ ] Implement anomaly queue depth tracking → [GITHUB-ISSUE-TBD]
- [ ] Implement AI confidence score tracking → [GITHUB-ISSUE-TBD]
- [ ] Implement entry posting success rate tracking → [GITHUB-ISSUE-TBD]
- [ ] Create MetricsCollectionJob (runs every 5 minutes) → [GITHUB-ISSUE-TBD]
- [ ] Build /admin/metrics dashboard (superuser-only) → [GITHUB-ISSUE-TBD]
- [ ] Configure structured logging (JSON format) → [GITHUB-ISSUE-TBD]
- [ ] Set up email alerts for critical thresholds → [GITHUB-ISSUE-TBD]

**Deliverables:**
- `app/services/metrics_tracker.rb` with all tracking methods
- `app/jobs/metrics_collection_job.rb` scheduled via Solid Queue
- `app/controllers/admin/metrics_controller.rb` with dashboard view
- `app/views/admin/metrics/index.html.erb` with color-coded metrics
- Alert email configuration in `config/initializers/alerts.rb`

**Validation Criteria:**
- MetricsCollectionJob runs every 5 minutes
- All business metrics tracked and stored in Rails.cache
- /admin/metrics dashboard accessible to superusers only
- Metrics color-coded (green/yellow/red) based on thresholds
- Email alerts sent when thresholds exceeded
- Structured logging outputs JSON to production.log

### Risks & Mitigations

#### Risk: money-rails Incompatible with Rails 8
- **Likelihood:** Medium
- **Impact:** High (critical for accounting app)
- **Mitigation:**
  1. Thorough testing in Phase 4 (dedicated 2 days)
  2. Fallback plan: Migrate to plain `money` gem + custom ActiveRecord integration
  3. Alternative: Write lightweight Money value object from scratch (US-only, simpler)
  4. **Rollback:** Downgrade to Rails 7 if money-rails is blocker (unlikely)

#### Risk: Solid Queue Performance Insufficient
- **Likelihood:** Low (adequate for <10,000 jobs/min)
- **Impact:** Medium (slow background processing)
- **Mitigation:**
  1. Monitor job queue depth in production
  2. Optimize job classes (smaller, faster jobs)
  3. Add database indexes on Solid Queue tables
  4. **Rollback:** Migrate to Sidekiq + Redis if queue depth consistently >1,000

#### Risk: Importmaps CDN (jspm.io) Outage
- **Likelihood:** Low (CDN SLA: 99.9%)
- **Impact:** Medium (broken JavaScript for users)
- **Mitigation:**
  1. Enable Subresource Integrity (SRI) for all imports
  2. Browser caching reduces CDN dependency
  3. Monitor jspm.io status page
  4. **Rollback:** Self-host critical JS packages in `/public/javascripts` as emergency fallback

#### Risk: pgvector Performance Degradation at Scale
- **Likelihood:** Low (<500M vectors is within pgvector limits)
- **Impact:** High (slow AI categorization)
- **Mitigation:**
  1. Use binary quantization (32x memory reduction)
  2. Proper HNSW indexes on vector columns
  3. Monitor query performance with pg_stat_statements
  4. **Rollback:** Migrate to Pinecone if queries exceed 500ms consistently

#### Risk: Heroku Cost Escalation
- **Likelihood:** Medium (at scale, PaaS becomes expensive)
- **Impact:** Medium (affects profitability)
- **Mitigation:**
  1. Track monthly costs per customer
  2. Optimize database queries (N+1, indexing)
  3. Use Heroku's horizontal scaling (dynos) judiciously
  4. **Rollback:** Migrate to Kamal deployment on VPS when monthly cost exceeds $1,000

#### Risk: Rate Limiting False Positives (Legitimate Users Blocked)
- **Likelihood:** Medium (users importing CSV with 200+ entries)
- **Impact:** Medium (user frustration, support burden)
- **Mitigation:**
  1. Document rate limits in UI ("You can upload up to 50 receipts per hour")
  2. Add "Request Limit Increase" button on throttle error page
  3. Superuser can whitelist IP addresses or user IDs in Rack::Attack config
  4. Monitor throttle logs for patterns—adjust limits if >5% users hitting them
  5. **Rollback:** Temporarily disable specific throttles via feature flag if widespread issues

#### Risk: Cache Invalidation Bugs (Stale Data Shown to Users)
- **Likelihood:** Medium (Russian Doll caching is subtle)
- **Impact:** High (incorrect account balances = regulatory violation)
- **Mitigation:**
  1. Comprehensive test coverage for cache invalidation logic (>95%)
  2. Add cache-busting query param in development: `?cache_buster=#{Time.current.to_i}`
  3. Manual cache flush button in /admin for emergency fixes
  4. Monitor "cache freshness" metric: compare cached vs. live balance calculations
  5. **Rollback:** Disable caching entirely via feature flag if data integrity issues arise

#### Risk: Custom Metrics Drift from Reality (Tracking Bugs)
- **Likelihood:** Medium (manual tracking prone to errors)
- **Impact:** Medium (incorrect alerts, missed issues)
- **Mitigation:**
  1. Daily reconciliation job: compare tracked metrics with actual database counts
  2. Alert on metric discrepancies > 10%
  3. Unit tests for MetricsTracker covering edge cases (nil values, zero counts)
  4. Fallback to Rails logger if metrics tracking fails (don't block user actions)
  5. **Rollback:** Add APM tool (Scout/Skylight) if custom metrics prove unreliable

#### Risk: Solid Cache Database Growth (Postgres Bloat)
- **Likelihood:** Low (Solid Cache has auto-cleanup)
- **Impact:** Medium (increased Postgres costs)
- **Mitigation:**
  1. Configure Solid Cache expiry_batch_size and max_age (prune old entries)
  2. Monitor solid_cache_entries table size weekly
  3. Manual VACUUM FULL if table exceeds 1GB
  4. **Rollback:** Migrate to Redis for caching if Postgres bloat becomes issue

### Open Questions

- [x] Should we add Solid Cache for HTTP caching? → **ANSWERED:** Yes, Solid Cache added for aggressive caching (Phase 7)
- [x] Should we add rate limiting? → **ANSWERED:** Yes, Rack::Attack added for OTP, AI API, and entry creation (Phase 6)
- [x] Should we add observability/metrics? → **ANSWERED:** Yes, custom business metrics tracking (Phase 8), defer APM until revenue justifies cost
- [ ] Do we need Good Job's advanced features (cron, recurring jobs)? → No, Solid Queue + custom scheduling adequate
- [ ] Should we self-host critical importmap packages? → No, jspm.io CDN sufficient with SRI
- [ ] Will we need horizontal scaling (multiple dynos) at launch? → No, single Standard-1X dyno sufficient for <100 users
- [ ] Should we add database read replicas? → No, single Postgres instance adequate until 1,000+ users
- [ ] Should rate limits be configurable per company? → Defer, start with global limits, add per-company whitelisting if needed
- [ ] Should we cache balance calculations (calculated, not stored per ADR 04.003)? → Yes, fragment cache with 5-min TTL (Phase 7)

### Testing Strategy

See **Testing Strategy** section in Decision for comprehensive details.

**Key metrics:**
- Unit test suite runs in <10 seconds
- Full test suite (including system tests) runs in <60 seconds
- 90%+ code coverage on models, services, jobs
- 100% pass rate required for CI

### Links

- [Rails 8 Release Notes](https://edgeguides.rubyonrails.org/8_0_release_notes.html)
- [Hotwire Documentation](https://hotwired.dev)
- [Solid Queue GitHub](https://github.com/basecamp/solid_queue)
- [pgvector Documentation](https://github.com/pgvector/pgvector)
- [Pundit Documentation](https://github.com/varvet/pundit)
- [ADR 01.002 - Heroku Deployment](./01.002.heroku-postgres-pgvector.md)
- [ADR 02.001 - Passwordless Auth](../02.auth/02.001.passwordless-otp-via-email.md)
- [ADR 06.001 - AI Strategy](../06.ai/06.001.openai-primary-haiku-fallback.md)
- [ADR 06.002 - pgvector Memory Cache](../06.ai/06.002.pgvector-memory-cache.md)

## Related ADRs

- [01.002 Heroku Postgres + pgvector Deployment](./01.002.heroku-postgres-pgvector.md) - Production infrastructure that runs this stack
- [02.001 Passwordless OTP Authentication](../02.auth/02.001.passwordless-otp-via-email.md) - Custom auth implementation using Rails 8 primitives
- [02.002 Pundit Company Roles](../02.auth/02.002.pundit-company-roles.md) - Authorization strategy using Pundit gem from this stack
- [03.001 Lightweight Company Tenancy](../03.tenancy/03.001.lightweight-company-tenancy.md) - Row-level tenancy pattern using Rails conventions
- [04.001 Minimal Double-Entry Ledger](../04.ledger/04.001.minimal-double-entry.md) - Core accounting models built on this stack
- [04.003 Calculated Balances (Not Stored)](../04.ledger/04.003.calculated-balances-no-stored.md) - Performance strategy leveraging Postgres indexes
- [05.001 Plaid Integration](../05.banks/05.001.plaid-integration.md) - Bank feeds using Plaid gem from this stack
- [06.001 OpenAI + Haiku AI Strategy](../06.ai/06.001.openai-primary-haiku-fallback.md) - AI implementation using ruby-openai and anthropic gems
- [06.002 pgvector Memory Cache](../06.ai/06.002.pgvector-memory-cache.md) - AI memory using pgvector extension from this stack
- [08.001 S3 Direct Upload + GPT-4o Vision](../08.documents/08.001.s3-direct-gpt4o-vision.md) - Document processing using Active Storage from this stack
- [10.001 TaxCloud Server-Side Only](../10.tax/10.001.taxcloud-server-side-only.md) - Sales tax using tax_cloud gem from this stack

## Notes

### Why This Stack Will Last 10+ Years

Rails 8 represents the culmination of 20 years of web development wisdom. By choosing boring, proven technology over cutting-edge trends, we ensure:

1. **Rails conventions are stable:** The MVC pattern hasn't changed significantly since Rails 2 (2008)
2. **Hotwire is the Rails future:** Official Rails 8 frontend strategy, backed by 37signals production usage
3. **Postgres is forever:** Battle-tested for 25+ years, pgvector is now part of core ecosystem
4. **Minimal dependencies = minimal risk:** Only 11 production gems, all Rails-native or core ecosystem

### Rails 8 Specific Features We're Using

- **Solid Queue:** Default background job processor (replaces Redis/Sidekiq)
- **Turbo 8:** Morphing for SPA-like UX, instant page updates
- **Stimulus 3:** Lightweight JavaScript framework for progressive enhancement
- **Propshaft:** New asset pipeline (replaces Sprockets)
- **Authentication primitives:** `has_secure_password` and related helpers
- **Mission Control Jobs:** Built-in admin UI for Solid Queue

### Production Usage References

- **37signals (Basecamp, HEY):** Running Solid Queue in production, processing 5.6M jobs/day
- **GitHub:** Using Turbo/Stimulus for progressive enhancement on github.com
- **Shopify:** Heavy Hotwire adoption across admin interfaces
- **pgvector at scale:** Supabase, Neon, Railway all offer managed pgvector (millions of vectors)

### Historical Context

This ADR supersedes earlier Rails stack decisions from 2015–2020 era:

- **Webpacker era (2017–2022):** Rails shipped with webpack, Node.js required—now optional
- **Sprockets era (2011–2024):** Rails 7 introduced Propshaft as simpler alternative
- **Sidekiq dominance (2012–2024):** Redis required for background jobs—now Rails has Solid Queue
- **Devise monopoly (2010–present):** Rails 8 authentication generator reduces need for Devise

### Future Considerations

**If requirements change dramatically:**

- **Migration to Kamal:** If Heroku costs exceed $1,000/month, Kamal 2 deployment is straightforward
- **Adding build tools:** If importmaps insufficient, esbuild can be added incrementally
- **Sidekiq migration:** If job volume exceeds 10,000/min, Sidekiq migration path is well-documented
- **money-rails replacement:** If gem becomes truly unmaintained, plain `money` gem + custom integration is ~200 lines of code

**We do NOT anticipate needing:**
- React/Vue/SPA (Hotwire is sufficient for accounting UI)
- GraphQL (REST + Turbo Frames = simpler)
- Microservices (Rails monolith scales to millions of users)
- NoSQL (Postgres + JSONB handles unstructured data)

---

**Last Updated:** 2025-11-21
**Status:** Accepted and battle-hardened
**Reviewed via:** /adr-analyze - Architectural compliance, security hardening, production readiness
**Next Review:** 2026-Q1 (annual stack review)

**Hardening Summary (2025-11-21):**
- ✅ Added Rack::Attack for rate limiting (OTP, AI API, entry creation)
- ✅ Added Solid Cache + Russian Doll caching for sub-200ms responses
- ✅ Added custom business metrics tracking (anomaly queue, AI confidence, entry posting success)
- ✅ Deferred expensive APM/error tracking until revenue justifies cost
- ✅ Added comprehensive security, caching, and observability implementation phases
- ✅ Added 5 new risk mitigations for rate limiting, cache invalidation, metrics drift
- ✅ Maintained service objects architecture (user preference for business logic organization)
